#!/bin/bash
# vim: set foldmethod=marker :
# {{{ Variables

subcommand="pull"
repo_args=()
dry_run=false
compact=true
clean_untracked=false
convert_utf16=false
list_stashes=false

cloned=0
updated=0
skipped=0
cleaned=0
converted=0
stashes=0

max_jobs=4
jobcount=0

start_time=$(date +%s)

# -------------------------------------------------------------------------- }}}
# {{{ Load Config

REPO_CONFIG="$HOME/.config/gits/repo_locations"

if [[ -f "$REPO_CONFIG" ]]; then
  source "$REPO_CONFIG"
else
  echo "ERROR: repo_locations file not found at $REPO_CONFIG" >&2
  exit 1
fi

# -------------------------------------------------------------------------- }}}
# {{{ usage

usage() {
  echo "Usage: gits [options] [repo-locations...]"
  echo
  echo "Options:"
  echo "  -h          Show help"
  echo "  -l          List repository locations"
  echo "  -c          Clone missing repositories (based on bash arrays)"
  echo "  -r          Pull changes for all repositories found on filesystem"
  echo "  -p          Alias for -r (pull)"
  echo "  -d          Dry-run (simulate actions)"
  echo "  -v          Verbose output"
  echo "  -x          Clean untracked files after pull"
  echo "  -U          Convert UTF-16 files to UTF-8 after pull"
  echo "  -s          List repositories with stash entries"
  exit 0
}

# -------------------------------------------------------------------------- }}}
# {{{ listRepos

listRepos() {
  echo "Available repository locations:"
  grep '^repo_' "$REPO_CONFIG" | sed 's/^repo_//;s/=.*//'
}

# -------------------------------------------------------------------------- }}}
# {{{ waitForJobs

waitForJobs() {
  while (( jobcount >= max_jobs )); do
    wait -n
    ((jobcount--))
  done
}

# -------------------------------------------------------------------------- }}}
# {{{ detectUtf16AndConvert

detectUtf16AndConvert() {
  local target_dir="$1"

  for file in "$target_dir"/*; do
    [[ -f "$file" ]] || continue
    if file "$file" | grep -q 'UTF-16'; then
      echo "üîÑ Converting UTF-16 to UTF-8: $(basename "$file")"
      if [[ "$dry_run" = false ]]; then
        iconv -f UTF-16 -t UTF-8 "$file" -o "$file.new" && mv "$file.new" "$file"
        ((converted++))
      fi
    fi
  done
}

# -------------------------------------------------------------------------- }}}
# {{{ checkForStashes

checkForStashes() {
  local dir="$1"

  if [[ -d "$dir/.git" ]]; then
    if (cd "$dir" && git stash list | grep -q .); then
      echo "üì¶ Stash found: $(basename "$dir")"
      ((stashes++))
    fi
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ cloneRepo

cloneRepo() {
  local url="$1"
  local target_dir="$2"

  if [[ ! -d "$target_dir/.git" ]]; then
    echo "‚û°Ô∏è  Cloning $(basename "$target_dir")"
    if [[ "$dry_run" = false ]]; then
      if git clone "$url" "$target_dir" &>/dev/null; then
        echo "‚úÖ  Cloned: $(basename "$target_dir")"
        ((cloned++))
      else
        echo "‚ùå  Failed to clone: $(basename "$target_dir")"
      fi
    fi
  else
    echo "‚ö†Ô∏è  Already exists: $(basename "$target_dir")"
    ((skipped++))
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ pullRepo

pullRepo() {
  local dir="$1"

  if [[ -d "$dir/.git" ]]; then
    echo "‚¨ÜÔ∏è  Pulling $(basename "$dir")"

    if [[ "$dry_run" = false ]]; then
      local needs_stash=0

      (cd "$dir" && git diff --quiet || needs_stash=1)

      if ((needs_stash)); then
        (cd "$dir" && git stash push -u -m "gits auto-stash" &>/dev/null)
      fi

      (cd "$dir" && git pull &>/dev/null)

      ((updated++))

      if [[ "$clean_untracked" = true ]]; then
        (cd "$dir" && git clean -fd &>/dev/null)
        ((cleaned++))
      fi

      if [[ "$convert_utf16" = true ]]; then
        detectUtf16AndConvert "$dir"
      fi
    fi
  else
    echo "‚ö†Ô∏è  Skipping non-repo: $(basename "$dir")"
    ((skipped++))
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ repo

repo() {
  local location="$1"
  local repos_var="repo_${location}"
  local basedir="$HOME/$location"

  mkdir -p "$basedir"

  if [[ "$list_stashes" = true ]]; then
    for dir in "$basedir"/*; do
      checkForStashes "$dir"
    done
    return
  fi

  if [[ "$subcommand" == "clone" ]]; then
    if [[ -n "${!repos_var}" ]]; then
      for entry in "${!repos_var}"; do
        local url="${entry%% *}"
        local alias="${entry##* }"
        local target_dir="$basedir/$alias"

        cloneRepo "$url" "$target_dir" &

        ((jobcount++))
        waitForJobs
      done
    else
      echo "‚ö†Ô∏è  No repositories defined for location: $location"
    fi
  elif [[ "$subcommand" == "pull" ]]; then
    for dir in "$basedir"/*; do
      [[ -d "$dir" ]] || continue

      pullRepo "$dir" &

      ((jobcount++))
      waitForJobs
    done
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Parse Arguments

if [[ $# -eq 0 ]]; then
  usage
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h)
      usage
      ;;
    -l)
      listRepos
      exit 0
      ;;
    -c)
      subcommand="clone"
      shift
      ;;
    -r|-p)
      subcommand="pull"
      shift
      ;;
    -d)
      dry_run=true
      shift
      ;;
    -v)
      compact=false
      shift
      ;;
    -x)
      clean_untracked=true
      shift
      ;;
    -U)
      convert_utf16=true
      shift
      ;;
    -s)
      list_stashes=true
      subcommand="pull"
      shift
      ;;
    *)
      repo_args+=("$1")
      shift
      ;;
  esac
done

# -------------------------------------------------------------------------- }}}
# {{{ Main

for location in "${repo_args[@]}"; do
  repo "$location"
done

wait

end_time=$(date +%s)
elapsed=$((end_time - start_time))
minutes=$((elapsed / 60))
seconds=$((elapsed % 60))

echo
echo "Summary:"
echo "  ‚û°Ô∏è  Cloned : $cloned"
echo "  ‚¨ÜÔ∏è  Updated: $updated"
echo "  ‚ö†Ô∏è  Skipped: $skipped"
echo "  üßπ  Cleaned : $cleaned"
echo "  üîÑ  UTF-16‚Üí8: $converted"
echo "  üì¶  Stash   : $stashes"
echo
echo "‚úÖ Done."
echo "‚è±Ô∏è  Elapsed time: ${minutes}m ${seconds}s"

# -------------------------------------------------------------------------- }}}
