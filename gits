#!/usr/bin/env bash
# vim: set foldmethod=marker :
# {{{ Define global Variables

defineVariables() {
  # Locaion of repositories to manage.
  REPO_CONFIG="$HOME/.config/gits/repo_locations"

  # Repositories defefined in REPO_CONFIG
  repo_names=()
  repo_location_names=()

  # Command line flags.
  all_mode=false
  clean_mode=false
  clone_mode=false
  delete_mode=false
  dry_run=false
  help=false
  list=false
  pull_mode=false
  repo_mode=false
  stash_list_mode=false
  utf_mode=false
  verbose=false

  # Parallel job counters.
  max_jobs=7
  jobcount=0

  # Count of work done.
  cleaned=0
  cloned=0
  converted=0
  deleted=0
  pulled=0
  skipped=0
  stashes=0
}

# -------------------------------------------------------------------------- }}}
# {{{ Define Icons

defineIcons() {
  ICON_CLEAN="üßπ"
  ICON_CLONE="‚û°Ô∏è"
  ICON_CONVERT="üîÑ"
  ICON_DELETE="‚ùå"
  ICON_DONE="‚úÖ"
  ICON_ERROR="‚ùå"
  ICON_INFO="‚ÑπÔ∏è"
  ICON_PULL="‚¨ÜÔ∏è"
  ICON_STASH="üì¶"
  ICON_SUCCESS="‚úÖ"
  ICON_TIME="‚è±Ô∏è"
  ICON_WARNING="‚ö†Ô∏è"
}

# -------------------------------------------------------------------------- }}}
# {{{ Colors and Icons helper functions.

echo_info()    { echo -e "\\e[34m$1\\e[0m"; }
echo_warn()    { echo -e "\\e[33m$1\e[0m"; }
echo_error()   { echo -e "\\e[31m$1\\e[0m"; }
echo_success() { echo -e "\\e[32m$1\\e[0m"; }

# -------------------------------------------------------------------------- }}}
# {{{ Start Timer

startTimer() {
  start_time=$(date +%s)
}

# -------------------------------------------------------------------------- }}}
# {{{ End timer

endTimer() {
  end_time=$(date +%s)
  elapsed=$((end_time - start_time))
  minutes=$((elapsed / 60))
  seconds=$((elapsed % 60))
}

# -------------------------------------------------------------------------- }}}
# {{{ Report final Status

reportStatus() {
  echo
  echo_info "Summary:"

  if [[ $clean_mode == true ]]; then
    echo "$ICON_CLEAN Cleaned : $cleaned"

  elif [[ $clone_mode == true ]]; then
    echo "$ICON_CLONE Cloned : $cloned"
    echo "$ICON_WARNING Skipped: $skipped"

  elif [[ $convert_mode == true ]]; then
    echo "$ICON_CONVERT Convert : $converted"

  elif [[ $delete_mode == true ]]; then
    echo "$ICON_DELETE Deleted : $deleted"

  elif [[ $pull_mode == true ]]; then
    echo "$ICON_PULL Pulled : $pulled"
    echo "$ICON_WARNING Skipped: $skipped"

  elif [[ $stash_list_mode == true ]]; then
    echo "$ICON_STASH Stashes : $stashes"

  elif [[ $utf_mode == true ]]; then
    echo "$ICON_CONVERT Converted : $converted"
  fi
  echo
  echo_success "$ICON_DONE Done."
  echo_info "$ICON_TIME Elapsed time: ${minutes}m ${seconds}s"
}

# -------------------------------------------------------------------------- }}}
# {{{ Load Config

loadConfiguration() {
  if [[ -f "$REPO_CONFIG" ]]; then
    source "$REPO_CONFIG"
  else
    echo_error "ERROR: repo_locations file not found at $REPO_CONFIG"
    exit 1
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Extract Repository Location Names

extractRepoLocationNames() {
  mapfile -t repo_location_names < <(grep '^repo_' "$REPO_CONFIG" | sed 's/^repo_//;s/=.*//')
}

# -------------------------------------------------------------------------- }}}
# {{{ Display usage

usage() {
  echo
  echo_info "Usage: gits [-h -l -R] [-r name -d -s -u -v -x] [-c | -p] [-n]"
  echo
  echo "Options:"
  echo "  -h  Show help."
  echo "  -l  List repository locations."
  echo "  -R  Apply modifiers to repository locations."
  echo
  echo "Repository Locations:"
  echo "  -r  name "
  echo "Modifiers:"
  echo "  -d  Delete repository location."
  echo "  -s  List repositories with stash entries."
  echo "  -u  Convert UTF-16 files to UTF-8."
  echo "  -v  Verbose output."
  echo "  -x  Clean untracked files."
  echo
  echo "Mutually exclusive actions"
  echo "  -c  Clone repositories in repository locations array."
  echo "  -p  Pull repositories in repository location array with safe stashing."
  echo
  echo "Dry-run"
  echo "  -n  Dry-run (simulate actions)"
}

# -------------------------------------------------------------------------- }}}
# {{{ Parse Arguments

validateArguments() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -R) all_mode=true ;;
      -c) clone_mode=true ;;
      -d) delete_mode=true ;;
      -h) help=true ;;
      -l) list=true ;;
      -n) dry_run=true ;;
      -p) pull_mode=true ;;
      -r) repo_mode=true ;;
      -s) stash_list_mode=true ;;
      -u) utf_mode=true ;;
      -v) verbose=true ;;
      -x) clean_mode=true ;;
      *) repo_names+=("$1") ;;
    esac
    shift
  done

  if [[ $help == true || $list == true ]]; then
    [[ $help == true ]] && usage
    [[ $list == true ]] && listRepositoryLocations
    exit 0
  fi

  # Repo location is mandatory.
  if [[ $repo_mode == false && $all_mode == false ]]; then
    echo_error "ERROR: -r repo-location or -R is mandatory."
    exit 1
  fi

  # Validate exclusivity
  if [[ $clone_mode == true && $pull_mode == true ]]; then
    echo_error "ERROR: -c and -p are mutually exclusive."
    exit 1
  fi

  # Clone mode
  if [[ $clone_mode == true ]]; then
    if [[ $clean_mode == true || $utf_mode == true || $stash_list_mode == true ]]; then
      echo_error "ERROR: -c cannot be combined with -x, -U, or -s."
      exit 1
    fi
  fi

  # Pull mode
  if [[ $pull_mode == true ]]; then
    if [[ $clean_mode == true || $utf_mode == true || $stash_list_mode == true ]]; then
      echo_error "ERROR: -p cannot be combined with -x, -U, or -s."
      exit 1
    fi
  fi

  # Process clean, UTF, or
  if [[ $repo_mode == true ]]; then
    if [[ ($clean_mode == true || $utf_mode == true || $stash_list_mode == true) \
       && ($clone_mode == true || $pull_mode == true) ]]; then
      echo_error "ERROR: -c or -p cannot be combined with -x, -U, or -s."
      exit 1
    fi
  fi

}

# -------------------------------------------------------------------------- }}}
# {{{ List Repository Locations

listRepositoryLocations() {
  echo
  echo_info "Available repository locations:"
  for rln in "${repo_location_names[@]}"; do
    echo "$rln"
  done
  echo
}

# -------------------------------------------------------------------------- }}}
# {{{ Run a job and return its completion status.

runJob() {
  status=$(eval "$@" &)
  waitForJobs
  ((jobcount++))
  echo $status
}

# -------------------------------------------------------------------------- }}}
# {{{ Wait for job to finish.

waitForJobs() {
  while (( jobcount >= max_jobs )); do
    wait -n
    ((jobcount--))
  done
}

# -------------------------------------------------------------------------- }}}
# {{{ Clone Repository

cloneRepository() {
  local url="$1"
  local target_dir="$2"

  if [[ ! -d "$target_dir/.git" ]]; then
    echo_info "$ICON_CLONE Cloning $(basename "$target_dir")"
    if [[ $dry_run == false ]]; then
      status=$(runJob "git clone $url $target_dir &>/dev/null")
      if [[ -z $status ]]; then
        ((cloned++))
        echo_success "$ICON_SUCCESS Cloned: $(basename "$target_dir")"
      else
        echo_error "$ICON_ERROR Failed to clone: $(basename "$target_dir")"
      fi
    fi
  else
    echo_warn "$ICON_WARNING Already exists: $(basename "$target_dir")"
    ((skipped++))
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Delete repository location

delteRepositoryLocation() {
  local basedir="$1"
  if [[ $dry_run == false ]]; then
    ((deleted++))
    if [[ $verbose == true ]]; then
      echo_warn "$ICON_DELETE Deleting $basedir"
      rm -rfv $basedir
    else
      rm -rf $basedir
    fi
  else
    echo_warn "$ICON_DELETE Would delete $basedir"
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Pull Repository

pullRepository() {
  local dir="$1"

  if [[ -d "$dir/.git" ]]; then
    echo_info "$ICON_PULL Pulling $(basename "$dir")"

    if [[ $dry_run == false ]]; then
      local dirty
      dirty=$(cd "$dir" && git status --porcelain)

      if [[ -n "$dirty" ]]; then
        echo_info "$ICON_STASH Stashing changes in $(basename "$dir")"
        if [[ $verbose == true ]]; then
          echo "$dirty"
        fi
        (cd "$dir" && git stash push -u -m "gits auto-stash" &>/dev/null)
        ((stashes++))
      fi

      (cd "$dir" && git pull &>/dev/null)

      ((pulled++))
    fi
  else
    echo_warn "$ICON_WARNING Skipping non-repo: $(basename "$dir")"
    ((skipped++))
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Process Repository

processRepository() {
  local location="$1"
  local repo_location_check="repo_${location}"
  local repos_location_name="repo_${location}[@]"
  local basedir="$HOME/$location"

  # Clone repositories.
  if [[ $clone_mode == true ]]; then
    if ! declare -p "$repo_location_check" &>/dev/null; then
      echo_error "ERROR: Repository location '$location' is not defined."
      exit 1
    fi

    # Make Repository Location
    mkdir -p "$basedir"

    # Repos referenced by repos_location_name.
    local repos=("${!repos_location_name}")
    for entry in "${repos[@]}"; do
      local url="${entry%% *}"
      local alias="${entry##* }"
      local target_dir="$basedir/$alias"

      cloneRepository "$url" "$target_dir"
    done

  # Pull repositories.
  elif [[ $pull_mode == true ]]; then
    for dir in "$basedir"/*; do
      [[ -d "$dir" ]] || continue
      status=$(runJob "pullRepository $dir")
    done

  # Delete repository location
  elif [[ $delete_mode == true ]]; then
   status=$(runJob "delteRepositoryLocation $basedir")

  # Other repository actions.
  elif [[ $repo_mode == true ]]; then
    for dir in "$basedir"/*; do
      [[ -d "$dir" ]] || continue

      status=$(runJob "processRepositoryActions $dir")
    done
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Process Repository Actions

processRepositoryActions() {
  local dir="$1"
  [[ -d "$dir/.git" ]] || return

  if [[ $clean_mode == true ]]; then
    echo_info "$ICON_CLEAN Cleaning untracked files: $(basename "$dir")"
    if [[ $verbose == true ]]; then
      (cd "$dir" && git clean -fd)
    else
      (cd "$dir" && git clean -fdq)
    fi
    ((cleaned++))
  fi

  if [[ $utf_mode == true ]]; then
    for file in "$dir"/*; do
      [[ -f "$file" ]] || continue
      if file "$file" | grep -q 'UTF-16'; then
        echo_info "$ICON_CONVERT Converting UTF-16 to UTF-8: $(basename "$file")"
        if [[ $dry_run == false ]]; then
          iconv -f UTF-16 -t UTF-8 "$file" -o "$file.new" && mv "$file.new" "$file"
          ((converted++))
        fi
      fi
    done
  fi

  if [[ $stash_list_mode == true ]]; then
    local cmdVerbose="git status -s -u && git stash list"
    local cmdSilent="(git status -s -u && git stash list) | grep -q ."
    if [[ $verbose == true ]]; then
      if (cd "$dir" && eval "$cmdSilent"); then
        echo_info "$ICON_STASH Change found: $(basename "$dir")"
        # Run verbose command to list changes.
        (cd "$dir" && eval "$cmdVerbose")
        ((stashes++))
      fi
    else
      if (cd "$dir" && eval "$cmdSilent"); then
        echo_info "$ICON_STASH Change found: $(basename "$dir")"
        ((stashes++))
      fi
    fi
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Main

main() {
  # Time all activities.
  startTimer

  # Setup activities.
  defineVariables
  defineIcons
  loadConfiguration
  extractRepoLocationNames

  # Validate user request.
  validateArguments "$@"

  # Process user requests.
  if [[ $all_mode == false ]]; then
    for rn in "${repo_names[@]}"; do
      processRepository "$rn"
    done
  else
    echo_info "$ICON_INFO All mode started."
    for rln in "${repo_location_names[@]}"; do
      echo_info "$ICON_CLONE Processing : $rln"
      repo_names+=("$rln")
      for repo in "${repo_names[@]}"; do
        processRepository "$repo"
      done
    done
  fi

  # Wait for all jobs to complete.
  wait

  # Calculate elapsed time.
  endTimer

  # Report final status.
  reportStatus
}

# -------------------------------------------------------------------------- }}}
main "$@"
